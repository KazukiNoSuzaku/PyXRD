# coding=UTF-8
# ex:ts=4:sw=4:et=on

# Copyright (c) 2013, Mathijs Dumon
# All rights reserved.
# Complete license can be found in the LICENSE file.

import logging
logger = logging.getLogger(__name__)

import re
from fractions import Fraction
from io import BytesIO

from PySide6.QtWidgets import QLabel, QApplication
from PySide6.QtGui import QPixmap, QPainter
from PySide6.QtCore import Qt

from matplotlib import rcParams
import matplotlib.mathtext as mathtext

pbmt_cache = dict()


def _get_dpi():
    """Lazy DPI lookup — QApplication must exist first."""
    app = QApplication.instance()
    if app is not None:
        screen = app.primaryScreen()
        if screen is not None:
            return screen.logicalDotsPerInch() or 96
    return 96


def create_pb_from_mathtext(text, align='center', weight='heavy', color='b', style='normal'):
    """
    Create a QPixmap from a mathtext string.
    Replaces the GTK/Cairo version that returned a GdkPixbuf.
    """
    global pbmt_cache
    if text not in pbmt_cache:
        dpi = _get_dpi()
        parts, fontsize = _handle_customs(text)

        pms = []
        total_width = 0
        total_height = 0

        old_params = (
            rcParams["font.weight"],
            rcParams["text.color"],
            rcParams["font.style"],
        )
        rcParams["font.weight"] = weight
        rcParams["text.color"] = color
        rcParams["font.style"] = style

        parser = mathtext.MathTextParser("Bitmap")
        for part in parts:
            buf = BytesIO()
            parser.to_png(buf, part, dpi=dpi, fontsize=fontsize)
            pm = QPixmap()
            pm.loadFromData(buf.getvalue())
            w, h = pm.width(), pm.height()
            total_width = max(total_width, w)
            total_height += h
            pms.append((pm, w, h))

        rcParams["font.weight"], rcParams["text.color"], rcParams["font.style"] = old_params

        result = QPixmap(max(total_width, 1), max(total_height, 1))
        result.fill(Qt.transparent)
        painter = QPainter(result)
        painter.setCompositionMode(QPainter.CompositionMode_SourceOver)

        offsety = 0
        for pm, w, h in pms:
            if align == 'center':
                offsetx = (total_width - w) // 2
            elif align == 'right':
                offsetx = total_width - w
            else:
                offsetx = 0
            painter.drawPixmap(offsetx, offsety, pm)
            offsety += h

        painter.end()
        del pms

        pbmt_cache[text] = result

    return pbmt_cache[text]


def create_image_from_mathtext(text, align='center', weight='heavy', color='b', style='normal'):
    """
    Create a QLabel widget from a mathtext string.
    Replaces the GTK version that returned a Gtk.Image.
    """
    label = QLabel()
    label.setPixmap(create_pb_from_mathtext(
        text, align=align, weight=weight, color=color, style=style
    ))
    return label


###############################
# Some convenience functions: #
###############################

def _handle_customs(text):
    if isinstance(text, bytes):
        text = text.decode('utf-8')

    if r"\larger" in text:
        fontsize = 20
    elif r"\large" in text:
        fontsize = 15
    else:
        fontsize = 10

    replacers = [
        (r"²", r"$^{2}$"),
        (r"³", r"$^{3}$"),
        (r"α", r"$\alpha$"),
        (r"β", r"$\beta$"),
        (r"γ", r"$\gamma$"),
        (r"δ", r"$\delta$"),
        (r"γ", r"$\digamma$"),
        (r"η", r"$\eta$"),
        (r"ι", r"$\iota$"),
        (r"κ", r"$\kappa$"),
        (r"λ", r"$\lambda$"),
        (r"μ", r"$\mu$"),
        (r"ω", r"$\omega$"),
        (r"φ", r"$\phi$"),
        (r"π", r"$\pi$"),
        (r"ψ", r"$\psi$"),
        (r"ρ", r"$\rho$"),
        (r"σ", r"$\sigma$"),
        (r"τ", r"$\tau$"),
        (r"θ", r"$\theta$"),
        (r"υ", r"$\upsilon$"),
        (r"ξ", r"$\xi$"),
        (r"ζ", r"$\zeta$"),
        (r"\larger", r""),
        (r"\large", r""),
        (r"\newline", r"$\newline$"),
    ]
    for val, rep in replacers:
        text = text.replace(val, rep)

    parts = text.replace("$$", "").split(r"\newline")
    while "$$" in parts:
        parts.remove("$$")
    return parts, fontsize


def mt_frac(val):
    val = Fraction(val).limit_denominator()
    if val.denominator > 1:
        return r"\frac{%d}{%d}" % (val.numerator, val.denominator)
    else:
        return r"%d" % val.numerator


def mt_range(lower, name, upper):
    return r"\left({ %s \leq %s \leq %s }\right)" % (mt_frac(lower), name, mt_frac(upper))


def get_plot_safe(expression):
    return r"".join(_handle_customs(expression)[0])


def get_string_safe(expression):
    replacers = [
        (r"$", r""),
        (r"\larger", r""),
        (r"\left", r""),
        (r"\right", r""),
        (r"\leq", r"≤"),
        (r"\geq", r"≥"),
        (r"\large", r""),
        (r"\newline", "\n"),
    ]
    for val, rep in replacers:
        expression = expression.replace(val, rep)

    regex_replacers = [
        (r"\\sum_\{(\S+)\}\^\{(\S+)\}", r"Σ(\1->\2)"),
        (r"(\S+)_(?:\{(\S+)\})", r"\1\2"),
        (r"(\S+)_(\S+)", r"\1\2"),
        (r"\\frac\{([^}])\}\{([^}])\}", r"\1\\\2"),
        (r"\\frac\{(.+)\}\{(.+)\}", r"(\1)\\(\2)"),
        (r"\(\{([^})]+)\}\)", r"(\1)")
    ]
    for regexpr, sub in regex_replacers:
        pattern = re.compile(regexpr)
        expression = pattern.sub(sub, expression)

    return expression
