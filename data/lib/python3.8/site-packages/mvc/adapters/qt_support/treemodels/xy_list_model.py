# coding=UTF-8
# ex:ts=4:sw=4:et=on

import logging
logger = logging.getLogger(__name__)

from collections import namedtuple

from PySide6.QtCore import QModelIndex, Qt, QTimer, Signal

from ....observers import Observer
from ....models.xydata import XYData
from .base_model import BaseQtObjectListModel


class PointMeta:
    @classmethod
    def get_column_properties(cls):
        return [("x", float), ("y", float)]

Point = namedtuple("Point", ["x", "y"])
Point.Meta = PointMeta


class XYListModel(BaseQtObjectListModel, Observer):
    """
    QAbstractItemModel wrapping an XYData model.
    Replaces XYListStore (GTK GenericTreeModel / BaseObjectListStore subclass).

    Observes data_changed signal on the XYData and emits Qt row
    insertion/removal/changed signals accordingly.

    columns_changed is emitted when the number of data columns changes.
    """

    columns_changed = Signal()

    _last_length = 0
    _last_num_col = 0
    _flush_scheduled = False
    _cache = None

    @property
    def _data(self):
        return getattr(self._model, self._prop_name, None)

    def is_wrapping(self, model, prop_name):
        return self._model == model and self._prop_name == prop_name

    # ------------------------------------------------------------------
    #  Init
    # ------------------------------------------------------------------
    def __init__(self, model, prop, parent=None):
        BaseQtObjectListModel.__init__(self, Point, parent)
        self._flush()

        self._model = model
        self._prop_name = prop.label
        _data = getattr(self._model, self._prop_name, None)
        assert isinstance(_data, XYData), (
            "Can only wrap XYData (or subclasses) instances to XYListModel, "
            "but got '%s' instead from property '%s' on model '%s'."
            % (_data, self._prop_name, self._model)
        )

        Observer.__init__(self, model=_data)

        self._last_length = len(_data)
        self._last_num_col = _data.num_columns

        self._emit_update()

    @Observer.observe("data_changed", signal=True)
    def on_data_changed(self, model, name, info):
        if model == self._data:
            self._emit_update()

    def _emit_update(self):
        self._schedule_flush()
        data = self._data
        if data is None:
            return

        # 1. Check if column count changed
        if self._last_num_col != data.num_columns:
            self.columns_changed.emit()
            self._last_num_col = data.num_columns

        # 2. Handle row count changes
        new_length = len(data)
        row_diff = new_length - self._last_length

        if row_diff > 0:
            first = self._last_length
            last = self._last_length + row_diff - 1
            self.beginInsertRows(QModelIndex(), first, last)
            self.endInsertRows()
        elif row_diff < 0:
            first = self._last_length + row_diff
            last = self._last_length - 1
            self.beginRemoveRows(QModelIndex(), first, last)
            self.endRemoveRows()

        self._last_length = new_length

        # 3. Emit dataChanged for all remaining rows
        if new_length > 0:
            top_left = self.index(0, 0)
            bottom_right = self.index(new_length - 1, self.columnCount() - 1)
            self.dataChanged.emit(top_left, bottom_right)

    def _schedule_flush(self):
        if not self._flush_scheduled:
            self._flush_scheduled = True
            QTimer.singleShot(500, self._flush)

    def _flush(self):
        self._cache = {}
        self._flush_scheduled = False

    # ------------------------------------------------------------------
    #  QAbstractItemModel interface
    # ------------------------------------------------------------------
    def columnCount(self, parent=QModelIndex()):
        data = self._data
        return data.num_columns if data is not None else 0

    def rowCount(self, parent=QModelIndex()):
        if parent.isValid():
            return 0
        data = self._data
        return len(data) if data is not None else 0

    def index(self, row, column, parent=QModelIndex()):
        if parent.isValid():
            return QModelIndex()
        data = self._data
        if data is None or row < 0 or row >= len(data):
            return QModelIndex()
        return self.createIndex(row, column, None)

    def parent(self, index):
        return QModelIndex()

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        if role in (Qt.DisplayRole, Qt.EditRole):
            data = self._data
            row = index.row()
            col = index.column()
            if data is None or row < 0 or row >= len(data):
                return None
            if col == self.c_x:
                return float(data.data_x[row])
            elif col >= self.c_y:
                return float(data.data_y[row, col - 1])
        return None

    def flags(self, index):
        if not index.isValid():
            return Qt.NoItemFlags
        return Qt.ItemIsEnabled | Qt.ItemIsSelectable

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            if section == 0:
                return "x"
            else:
                return "y%d" % section
        return None

    def __len__(self):
        data = self._data
        return data.size if data is not None else 0

    def get_objects(self):
        data = self._data
        if data is None:
            return []
        return [Point(x=data.data_x[i], y=data.data_y[i, 0]) for i in range(len(data))]

    def iter_objects(self):
        data = self._data
        if data is not None:
            for i in range(len(data)):
                yield Point(x=data.data_x[i], y=data.data_y[i, 0])

    pass  # end of class
