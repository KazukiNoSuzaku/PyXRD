# coding=UTF-8
# ex:ts=4:sw=4:et=on

import logging
logger = logging.getLogger(__name__)

from PySide6.QtCore import QModelIndex, Qt

from ....observers import TreeObserver
from .base_model import BaseQtObjectListModel


class ObjectTreeModel(BaseQtObjectListModel):
    """
    QAbstractItemModel wrapping a TreeNode tree of mvc model objects.
    Replaces ObjectTreeStore (GTK GenericTreeModel / BaseObjectListStore subclass).

    The property on 'model' named by 'prop.label' is expected to be a TreeNode
    (the root node).  Its children are the top-level items.  TreeObserver keeps
    us in sync with insertions/deletions.

    Internal pointer of each QModelIndex holds the TreeNode for that row.
    """

    _pending_delete_paths = None

    @property
    def _root_node(self):
        return getattr(self._model, self._prop_name, None)

    def is_wrapping(self, model, prop_name):
        return self._model == model and self._prop_name == prop_name

    # ------------------------------------------------------------------
    #  Init
    # ------------------------------------------------------------------
    def __init__(self, model, prop, parent=None):
        try:
            super().__init__(prop.data_type, parent)
        except ValueError as err:
            msg = (
                "ValueError (%r) raised when initializing ObjectTreeModel "
                "for model '%s' and data_type '%s'" % (err, model, prop.data_type)
            )
            raise ValueError(msg)

        self._model = model
        self._prop_name = prop.label
        self._pending_delete_paths = []

        self._observer = TreeObserver(
            self.on_item_inserted, self.on_item_deleted,
            on_deleted_before=self.on_item_deleted_before,
            prop_name=self._prop_name, model=self._model,
        )

    # ------------------------------------------------------------------
    #  Internal helpers
    # ------------------------------------------------------------------
    def _node_to_index(self, node, column=0):
        """Convert a TreeNode to a QModelIndex."""
        if node is None:
            return QModelIndex()
        parent_node = node.parent
        if parent_node is None:
            return QModelIndex()
        # Find row of node among parent's children
        try:
            indices = node.get_indices()
            row = indices[-1]
        except (AttributeError, IndexError, ValueError):
            return QModelIndex()
        return self.createIndex(row, column, node)

    def _indices_to_qt_parent(self, node):
        """Return the QModelIndex of a node's parent."""
        if node is None:
            return QModelIndex()
        parent_node = node.parent
        if parent_node is None:
            return QModelIndex()
        # parent_node's parent
        grandparent = parent_node.parent
        if grandparent is None:
            return QModelIndex()
        try:
            parent_indices = parent_node.get_indices()
            parent_row = parent_indices[-1]
        except (AttributeError, IndexError, ValueError):
            return QModelIndex()
        return self.createIndex(parent_row, 0, parent_node)

    # ------------------------------------------------------------------
    #  Observer callbacks
    # ------------------------------------------------------------------
    def on_item_inserted(self, item):
        try:
            indices = item.get_indices()
            row = indices[-1]
        except (AttributeError, IndexError, ValueError):
            logger.debug("on_item_inserted: cannot get indices for %s", item)
            return
        parent_idx = self._indices_to_qt_parent(item)
        self.beginInsertRows(parent_idx, row, row)
        self.endInsertRows()

    def on_item_deleted_before(self, item):
        try:
            indices = item.get_indices()
            row = indices[-1]
        except (AttributeError, IndexError, ValueError):
            self._pending_delete_paths.append(None)
            return
        parent_idx = self._indices_to_qt_parent(item)
        self._pending_delete_paths.append((parent_idx, row))
        self.beginRemoveRows(parent_idx, row, row)

    def on_item_deleted(self, item):
        if self._pending_delete_paths:
            entry = self._pending_delete_paths.pop()
            if entry is not None:
                self.endRemoveRows()

    # ------------------------------------------------------------------
    #  QAbstractItemModel interface
    # ------------------------------------------------------------------
    def rowCount(self, parent=QModelIndex()):
        if not parent.isValid():
            root = self._root_node
            return root.child_count if root is not None else 0
        node = parent.internalPointer()
        if node is None:
            return 0
        return node.child_count if hasattr(node, "child_count") else 0

    def index(self, row, column, parent=QModelIndex()):
        root = self._root_node
        if root is None:
            return QModelIndex()
        if not parent.isValid():
            parent_node = root
        else:
            parent_node = parent.internalPointer()
            if parent_node is None:
                return QModelIndex()
        try:
            child = parent_node.get_child_node(row)
        except (IndexError, AttributeError):
            return QModelIndex()
        if child is None:
            return QModelIndex()
        return self.createIndex(row, column, child)

    def parent(self, index):
        if not index.isValid():
            return QModelIndex()
        node = index.internalPointer()
        if node is None:
            return QModelIndex()
        return self._indices_to_qt_parent(node)

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        if role in (Qt.DisplayRole, Qt.EditRole):
            node = index.internalPointer()
            col = index.column()
            if node is not None and 0 <= col < len(self._columns):
                try:
                    value = getattr(node.object, self._columns[col][0])
                    return value if value is not None else ""
                except AttributeError:
                    return ""
        return None

    def flags(self, index):
        if not index.isValid():
            return Qt.NoItemFlags
        return Qt.ItemIsEnabled | Qt.ItemIsSelectable

    # ------------------------------------------------------------------
    #  Convenience helpers (mirror GTK store interface)
    # ------------------------------------------------------------------
    def get_objects(self):
        root = self._root_node
        if root is None:
            return []
        return [node.object for node in root.iter_children()]

    def iter_objects(self):
        root = self._root_node
        if root is not None:
            for node in root.iter_children():
                yield node.object

    def get_tree_node(self, index):
        if index.isValid():
            return index.internalPointer()
        return None

    def get_tree_node_object(self, index):
        node = self.get_tree_node(index)
        return node.object if node is not None else None

    def set_value(self, index, column, value):
        if index.isValid():
            node = index.internalPointer()
            if node is not None:
                setattr(node.object, self._columns[column][0], value)
                self.dataChanged.emit(index, index)

    pass  # end of class
