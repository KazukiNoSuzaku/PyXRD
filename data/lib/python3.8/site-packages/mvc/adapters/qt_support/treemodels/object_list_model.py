# coding=UTF-8
# ex:ts=4:sw=4:et=on

import logging
logger = logging.getLogger(__name__)

from weakref import WeakKeyDictionary

from PySide6.QtCore import QModelIndex, Qt

from ....observers import ListObserver, ListItemObserver
from .base_model import BaseQtObjectListModel


class ObjectListModel(BaseQtObjectListModel):
    """
    QAbstractItemModel wrapping a Python list of mvc model objects.
    Replaces ObjectListStore (GTK GenericTreeModel / BaseObjectListStore subclass).

    The property on 'model' named by 'prop.label' is expected to be a Python list
    whose items are instances of 'prop.data_type'.  ListObserver/ListItemObserver
    keep us in sync with mutations.

    Qt rule: beginInsertRows/beginRemoveRows must bracket data changes.
    Because ListObserver fires on_inserted AFTER mutation and
    on_deleted_before BEFORE mutation, we use:
      - on_item_deleted_before → beginRemoveRows (data still present → can find row)
      - on_item_deleted        → endRemoveRows
      - on_item_inserted       → beginInsertRows + endInsertRows (data already present)
    """

    _pending_delete_row = None

    @property
    def _data(self):
        if self._model is not None:
            return getattr(self._model, self._prop_name, None)
        return []

    def is_wrapping(self, model, prop_name):
        return self._model == model and self._prop_name == prop_name

    # ------------------------------------------------------------------
    #  Init
    # ------------------------------------------------------------------
    def __init__(self, model, prop, parent=None):
        super().__init__(prop.data_type, parent)
        self._model = model
        self._prop_name = prop.label

        self._observer = ListObserver(
            self.on_item_inserted, self.on_item_deleted,
            on_deleted_before=self.on_item_deleted_before,
            prop_name=self._prop_name, model=self._model,
        )

        self._list_item_observers = WeakKeyDictionary()
        for item in (self._data or []):
            self._observe_item(item)

    def _observe_item(self, item):
        obs = ListItemObserver(self.on_item_changed, model=item)
        self._list_item_observers[item] = obs

    def _unobserve_item(self, item):
        obs = self._list_item_observers.get(item, None)
        if obs is not None:
            obs.clear()

    # ------------------------------------------------------------------
    #  Observer callbacks
    # ------------------------------------------------------------------
    def on_item_changed(self, item):
        data = self._data
        if not data:
            return
        try:
            row = data.index(item)
        except ValueError:
            return
        top_left = self.index(row, 0)
        bottom_right = self.index(row, self.columnCount() - 1)
        self.dataChanged.emit(top_left, bottom_right)

    def on_item_inserted(self, item):
        data = self._data
        if not data:
            return
        try:
            row = data.index(item)
        except ValueError:
            logger.debug("on_item_inserted: item not in data: %s", item)
            return
        # Data already present → bracket tells views a new row appeared at 'row'
        self.beginInsertRows(QModelIndex(), row, row)
        self._observe_item(item)
        self.endInsertRows()

    def on_item_deleted_before(self, item):
        data = self._data
        if not data:
            self._pending_delete_row = None
            return
        try:
            row = data.index(item)
        except ValueError:
            self._pending_delete_row = None
            return
        self._unobserve_item(item)
        self._pending_delete_row = row
        self.beginRemoveRows(QModelIndex(), row, row)

    def on_item_deleted(self, item):
        if self._pending_delete_row is not None:
            self.endRemoveRows()
            self._pending_delete_row = None

    # ------------------------------------------------------------------
    #  QAbstractItemModel interface
    # ------------------------------------------------------------------
    def rowCount(self, parent=QModelIndex()):
        if parent.isValid():
            return 0
        data = self._data
        return len(data) if data is not None else 0

    def index(self, row, column, parent=QModelIndex()):
        if parent.isValid():
            return QModelIndex()
        data = self._data
        if data is None or row < 0 or row >= len(data):
            return QModelIndex()
        return self.createIndex(row, column, data[row])

    def parent(self, index):
        return QModelIndex()

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        if role in (Qt.DisplayRole, Qt.EditRole):
            item = index.internalPointer()
            col = index.column()
            if item is not None and 0 <= col < len(self._columns):
                value = getattr(item, self._columns[col][0], None)
                if value is None:
                    try:
                        value = self._columns[col][1]()
                    except TypeError:
                        value = ""
                return value
        return None

    # ------------------------------------------------------------------
    #  Convenience helpers (mirror GTK store interface)
    # ------------------------------------------------------------------
    def get_objects(self):
        return list(self._data) if self._data else []

    def iter_objects(self):
        if self._data:
            yield from self._data

    def get_object(self, index):
        """Return the model object for the given QModelIndex."""
        if index.isValid():
            return index.internalPointer()
        return None

    def get_index_for_object(self, obj):
        """Return a QModelIndex(row=N, col=0) for the given object."""
        data = self._data
        if data:
            try:
                row = data.index(obj)
                return self.index(row, 0)
            except ValueError:
                pass
        return QModelIndex()

    def set_value(self, index, column, value):
        """Set an attribute on the object at the given index."""
        if index.isValid():
            item = index.internalPointer()
            if item is not None:
                setattr(item, self._columns[column][0], value)
                self.on_item_changed(item)

    pass  # end of class
