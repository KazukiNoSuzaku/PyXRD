# coding=UTF-8
# ex:ts=4:sw=4:et=on

import logging
logger = logging.getLogger(__name__)

from PySide6.QtWidgets import QWidget
from PySide6.QtUiTools import QUiLoader
from PySide6.QtCore import QFile, QIODevice


class QtBuilder(object):
    """
    Drop-in replacement for Gtk.Builder using Qt .ui files.

    Mirrors the Gtk.Builder interface used by mvc/view.py:
      - add_from_file(path)  — loads a Qt Designer .ui file
      - get_object(name)     — returns a widget by objectName
      - get_objects()        — returns all named widgets
      - connect_signals(dic) — connects Qt signals to handler callables
    """

    def __init__(self):
        self._top_widget = None
        self._object_map = {}  # objectName -> QWidget

    def add_from_file(self, path):
        """Load a Qt Designer .ui file and populate the internal widget map."""
        loader = QUiLoader()
        ui_file = QFile(path)
        if not ui_file.open(QIODevice.ReadOnly):
            raise IOError("Cannot open Qt .ui file: %s" % path)
        widget = loader.load(ui_file)
        ui_file.close()
        if widget is None:
            raise IOError("QUiLoader failed to load: %s" % path)
        self._top_widget = widget
        self._populate_object_map(widget)

    def _populate_object_map(self, widget):
        """Recursively register all named child widgets."""
        if widget is None:
            return
        name = widget.objectName()
        if name:
            self._object_map[name] = widget
        for child in widget.findChildren(QWidget):
            child_name = child.objectName()
            if child_name:
                self._object_map[child_name] = child

    def get_object(self, name):
        """Return the widget with the given objectName, or None."""
        return self._object_map.get(name, None)

    def get_objects(self):
        """Return all widgets registered in the object map."""
        return list(self._object_map.values())

    def connect_signals(self, dic):
        """
        Connect Qt signals to handler callables.

        Uses Qt's connectSlotsByName convention: signal names in the .ui file
        that match on_<objectName>_<signalName> are auto-connected. Any
        remaining entries in *dic* are connected explicitly if the widget
        exposes a matching signal name.

        *dic* maps handler names (strings) to callables.
        """
        if self._top_widget is None:
            return

        # Auto-connect slots following on_<objectName>_<signalName> pattern
        for handler_name, handler in dic.items():
            if not handler_name.startswith("on_"):
                continue
            parts = handler_name[3:].rsplit("_", 1)
            if len(parts) != 2:
                continue
            obj_name, signal_name = parts
            widget = self.get_object(obj_name)
            if widget is None:
                continue
            signal = getattr(widget, signal_name, None)
            if signal is not None and callable(getattr(signal, 'connect', None)):
                try:
                    signal.connect(handler)
                except Exception:
                    logger.warning("Could not connect signal %s on %s" % (
                        signal_name, obj_name))
