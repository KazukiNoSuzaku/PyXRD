# coding=UTF-8
# ex:ts=4:sw=4:et=on

import logging
logger = logging.getLogger(__name__)

from PySide6.QtWidgets import QTreeView, QAbstractItemView

from ..abstract_adapter import AbstractAdapter


# ---------------------------------------------------------------------------
#  Wrapper helpers â€” mirror gtk_support/tree_view_adapters.py convenience fns
# ---------------------------------------------------------------------------

def _wrap_property(model, prop, model_class):
    """
    Lazily create (or reuse) a Qt tree/list model wrapper for a model property.
    The wrapper is cached on the model as __{label}_treemodel_wrapper.
    """
    wrapper = getattr(model, "__%s_treemodel_wrapper" % prop.label, None)
    if wrapper is None or not wrapper.is_wrapping(model, prop.label):
        wrapper = model_class(model, prop)
    setattr(model, "__%s_treemodel_wrapper" % prop.label, wrapper)
    return wrapper


def wrap_list_property_to_treemodel(model, prop):
    """Wrap a list property to an ObjectListModel."""
    from .treemodels import ObjectListModel
    return _wrap_property(model, prop, ObjectListModel)


def wrap_treenode_property_to_treemodel(model, prop):
    """Wrap a TreeNode property to an ObjectTreeModel."""
    from .treemodels import ObjectTreeModel
    return _wrap_property(model, prop, ObjectTreeModel)


def wrap_xydata_to_treemodel(model, prop):
    """Wrap an XYData property to an XYListModel."""
    from .treemodels import XYListModel
    return _wrap_property(model, prop, XYListModel)


# ---------------------------------------------------------------------------
#  Abstract base adapter
# ---------------------------------------------------------------------------

class AbstractQtTreeViewAdapter(AbstractAdapter):
    """
    Abstract base for ObjectListViewAdapter, XYListViewAdapter,
    and ObjectTreeViewAdapter.

    Mirrors gtk_support/tree_view_adapters.py::AbstractTreeViewAdapter.
    """

    toolkit = "qt"
    _check_widget_type = QTreeView

    def __init__(self, controller, prop, widget):
        super().__init__(controller, prop, widget)
        if self._check_widget_type is not None:
            if not isinstance(widget, self._check_widget_type):
                raise TypeError(
                    "A '%s' can only be used for (a subclass of) '%s', not '%s'!"
                    % (type(self), self._check_widget_type, type(widget))
                )
        self._connect_widget()

    def _connect_widget(self):
        self._widget.setModel(self._treemodel)
        # Call controller.setup_<prop>_tree_view(treemodel, widget) if present
        setup = getattr(
            self._controller, "setup_%s_tree_view" % self._prop.label, None
        )
        if callable(setup):
            setup(self._treemodel, self._widget)
        else:
            logger.error(
                "Could not find setup callable for tree view widget '%s' adapted to '%s'",
                self._widget, self._prop.label,
            )

    def _disconnect_widget(self, widget=None):
        self._widget.setModel(None)

    def _connect_model(self):
        pass

    def _disconnect_model(self, model=None):
        pass

    def _read_widget(self):
        pass

    def _write_widget(self, val):
        pass

    def _read_property(self, *args):
        pass

    def _write_property(self, value, *args):
        pass

    pass  # end of class


# ---------------------------------------------------------------------------
#  Concrete adapters
# ---------------------------------------------------------------------------

class ObjectListViewAdapter(AbstractQtTreeViewAdapter):
    """
    Adapter for a QTreeView (used as a flat list) of mvc model objects.
    widget_type tag: "object_list_view"
    """

    widget_types = ["object_list_view"]

    def __init__(self, controller, prop, widget):
        assert hasattr(prop, "data_type"), (
            "ObjectListViewAdapter requires 'data_type' on the property descriptor.\n"
            "Controller: '%s', Model: '%s', Property: '%s'"
            % (controller, controller.model, prop.label)
        )
        self._treemodel = wrap_list_property_to_treemodel(controller.model, prop)
        super().__init__(controller, prop, widget)

    pass  # end of class


class XYListViewAdapter(AbstractQtTreeViewAdapter):
    """
    Adapter for a QTreeView displaying XYData.
    widget_type tag: "xy_list_view"
    """

    widget_types = ["xy_list_view"]

    def __init__(self, controller, prop, widget):
        self._treemodel = wrap_xydata_to_treemodel(controller.model, prop)
        super().__init__(controller, prop, widget)

    pass  # end of class


class ObjectTreeViewAdapter(AbstractQtTreeViewAdapter):
    """
    Adapter for a QTreeView displaying a tree of mvc model objects.
    widget_type tag: "object_tree_view"
    """

    widget_types = ["object_tree_view"]

    def __init__(self, controller, prop, widget):
        self._treemodel = wrap_treenode_property_to_treemodel(controller.model, prop)
        super().__init__(controller, prop, widget)

    pass  # end of class
